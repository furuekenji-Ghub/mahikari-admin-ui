<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>View | World Divine Light Admin</title>
  <link rel="stylesheet" href="/css/style.css" />
  <style>
    .muted { color:#666; font-size:0.9em; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; background:#f7fafc; color:#344; white-space:nowrap; }
    .grid { display:grid; grid-template-columns:220px 1fr; gap:8px 14px; margin-top:12px; }
    .k { font-weight:700; }
    .v { border-bottom:1px dashed #ddd; padding-bottom:4px; }
    hr { margin:18px 0; }

    .note { border:1px solid #ddd; border-radius:10px; padding:10px 12px; margin:10px 0; background:#fff; }
    textarea { width:100%; min-height:120px; padding:10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    pre { white-space:pre-wrap; margin:8px 0 0; }
    .appendBox { margin-top:10px; display:none; }
    .appendBox textarea { min-height:140px; }
    .danger { border:1px solid #b00020; color:#b00020; }

    .section-title { display:flex; align-items:baseline; gap:8px; flex-wrap:wrap; }
    .h-ja { font-size:0.85em; font-weight:600; color:#444; }

    .noteHead { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:6px; }
    .noteHeadLeft { display:flex; flex-direction:column; gap:6px; align-items:flex-start; }
    .dateRight { font-size:12px; color:#667; white-space:nowrap; padding-top:2px; }
  </style>
</head>
<body>

<header>
  <h2>View <span class="h-ja">（個人詳細）</span></h2>
  <small><a href="/contacts.html">← Back to Contacts / 連絡先一覧へ戻る</a></small>
</header>

<div class="card">
  <div class="muted" id="meta">Loading...</div>

  <div class="section-title">
    <h3 style="margin: 14px 0 6px;">Profile</h3>
    <span class="h-ja">（基本情報）</span>
  </div>

  <div class="grid" id="profile"></div>

  <hr />

  <div class="section-title">
    <h3 style="margin: 14px 0 6px;">Seshin card</h3>
    <span class="h-ja">（施真カード）</span>
    <span id="mePill" class="pill" style="display:none;"></span>
  </div>

  <p class="muted" style="margin-top:0;">
    Seshin card is stored and displayed as plain content only.
    <span class="h-ja">（本文のみを保存・表示します）</span>
  </p>

  <textarea id="newNote" placeholder="Type a note... / メモを入力してください"></textarea>
  <div class="row">
    <button type="button" id="addBtn">Add Note / 追加</button>
    <button type="button" id="reloadBtn">Reload / 再読み込み</button>
    <span class="muted" id="status"></span>
  </div>

  <div id="notes"></div>
</div>

<script>
  const BRANCH_LABEL = {
    canada:"Canada", new_york:"New York", chicago:"Chicago", los_angeles:"Los Angeles",
    california:"California", houston:"Houston", hawaii:"Hawaii"
  };
  const ACTIVE_LABEL = {
    non_kamikumite:"Non Kamikumite",
    basic_kamikumite:"Basic Kamikumite",
    intermediate_kamikumite:"Intermediate Kamikumite",
    advanced_kamikumite:"Advanced Kamikumite",
    kanbu:"Kanbu",
    doshi:"Doshi",
    sleeping_kamikumite:"Sleeping Kamikumite"
  };

  const META_PREFIX = "[[APPENDED_BY:";
  const META_SUFFIX = "]]";

  function qs(id){ return document.getElementById(id); }
  function setStatus(msg){ qs("status").textContent = msg || ""; }

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function getId(){
    const u = new URL(location.href);
    return u.searchParams.get("id") || "";
  }

  async function api(path, opts={}){
    const res = await fetch(path, { ...opts, headers: { ...(opts.headers||{}) }});
    const text = await res.text();
    let data;
    try { data = text ? JSON.parse(text) : null; } catch { data = { raw:text }; }
    return { ok: res.ok, status: res.status, data, raw:text };
  }

  function htmlToPlainText(html) {
    if (!html) return "";
    try {
      const normalized = String(html)
        .replaceAll("<br>", "\n").replaceAll("<br/>", "\n").replaceAll("<br />", "\n")
        .replaceAll("</p>", "\n").replaceAll("</div>", "\n").replaceAll("</li>", "\n");
      const doc = new DOMParser().parseFromString(normalized, "text/html");
      const text = (doc.body && doc.body.textContent) ? doc.body.textContent : "";
      return text.replace(/\n{3,}/g, "\n\n").trim();
    } catch {
      return String(html);
    }
  }

  function extractMetaAndStrip(plainText){
    const t = String(plainText || "");
    if (!t.startsWith(META_PREFIX)) return { appendedBy:"", textWithoutMeta:t };
    const end = t.indexOf(META_SUFFIX);
    if (end < 0) return { appendedBy:"", textWithoutMeta:t };
    const name = t.substring(META_PREFIX.length, end).trim();
    let rest = t.substring(end + META_SUFFIX.length);
    if (rest.startsWith("\n")) rest = rest.slice(1);
    return { appendedBy:name, textWithoutMeta:rest };
  }

  function stripAuditLines(plainText) {
    if (!plainText) return "";
    const lines = String(plainText).split("\n");
    const dropPrefix = ["Added by:","Added at:","Appended by:","Appended at:","[Added by:","[Added at:","[Appended by:","[Appended at:"];
    const kept = [];
    for (const line of lines){
      const t = line.trim();
      if (dropPrefix.some(p => t.startsWith(p))) continue;
      kept.push(line);
    }
    return kept.join("\n").replace(/\n{3,}/g, "\n\n").trim();
  }

  function looksLikeHtml(s){
    const t = String(s || "").trim();
    // very simple heuristic
    return t.startsWith("<") && t.includes(">") && /<\/?[a-z][\s\S]*>/i.test(t);
  }

  function normalizeNoteBodyToPlain(textOrHtml){
    const raw = String(textOrHtml || "");
    if (looksLikeHtml(raw)) return htmlToPlainText(raw);
    return raw;
  }

  function toEpoch(note){
    if (note?.createdate) {
      const p = Date.parse(String(note.createdate));
      if (!Number.isNaN(p)) return p;
    }
    const created = note?.hs_createdate;
    const ts = note?.hs_timestamp;
    const p1 = created ? Date.parse(String(created)) : NaN;
    if (!Number.isNaN(p1)) return p1;
    const n2 = Number(ts);
    if (!Number.isNaN(n2) && Number.isFinite(n2)) return n2;
    const p2 = ts ? Date.parse(String(ts)) : NaN;
    if (!Number.isNaN(p2)) return p2;
    return 0;
  }

  let NOTES_CACHE = [];
  let CONTACT_ID = "";

  async function loadMe(){
    const r = await api("/api/me");
    if (!r.ok) return;
    const payload = r.data?.ok === true ? r.data : r.data;
    const label = (payload?.name || payload?.email || "").trim();
    if (label) {
      const pill = qs("mePill");
      pill.textContent = "Logged in as: " + label;
      pill.style.display = "inline-block";
    }
  }

  function branchLabel(v){ const k=String(v||"").trim(); return BRANCH_LABEL[k] || k; }
  function activeLabel(v){ const k=String(v||"").trim(); return ACTIVE_LABEL[k] || k; }

  function renderProfile(props, id){
    const orderKeys = [
      ["firstname","First Name"],["middle_name","Middle Name"],["lastname","Last Name"],["email","Email"],
      ["member_id","Member ID"],["branch","Branch"],["active_status","Active Status"],
      ["preferred_language","Preferred Language"],["mobilephone","Mobile Phone"],["address","Address"],
      ["city","City"],["state__province","State / Province"],["zip","ZIP"],["gender","Gender"],
      ["date_of_birth","Date of Birth"],["taking_medication","Taking Medication"],["medication_names","Medication Names"],
      ["initial_notes","Initial Notes"],["notes_last_updated","Notes Last Updated"],["createdate","Create Date"]
    ];

    const grid = qs("profile");
    grid.innerHTML = "";

    const name = [props.firstname, props.middle_name, props.lastname].filter(Boolean).join(" ");
    qs("meta").innerHTML = `<span class="pill">Contact ID: ${esc(id)}</span> <b>${esc(name||"(no name)")}</b> <span class="muted">(${esc(props.email||"")})</span>`;

    for (const [key,label] of orderKeys){
      let v = (props && props[key] != null) ? String(props[key]) : "";
      if (key === "branch") v = branchLabel(v);
      if (key === "active_status") v = activeLabel(v);

      const kDiv = document.createElement("div");
      kDiv.className = "k";
      kDiv.textContent = label;

      const vDiv = document.createElement("div");
      vDiv.className = "v";
      vDiv.textContent = v;

      grid.appendChild(kDiv);
      grid.appendChild(vDiv);
    }
  }

  function renderNotes(){
    const box = qs("notes");
    box.innerHTML = "";

    const notes = NOTES_CACHE.slice().sort((a,b)=>toEpoch(b)-toEpoch(a));
    if (!notes.length){
      box.innerHTML = `<p class="muted">No notes found. / メモはまだありません。</p>`;
      return;
    }

    for (const note of notes){
      const noteId = note.id;

      let appendedBy = (note.appendedBy || "").trim();
      let bodyText = "";

      if (note.body != null) {
        // new worker payload
        bodyText = normalizeNoteBodyToPlain(note.body || "");
      } else {
        // compat payload with hs_note_body
        const plainAll = normalizeNoteBodyToPlain(note.hs_note_body || "");
        const meta = extractMetaAndStrip(plainAll);
        if (!appendedBy) appendedBy = meta.appendedBy || "";
        bodyText = normalizeNoteBodyToPlain(stripAuditLines(meta.textWithoutMeta));
      }

      const dateStr = new Date(toEpoch(note)).toLocaleString();

      const div = document.createElement("div");
      div.className = "note";
      div.innerHTML = `
        <div class="noteHead">
          <div class="noteHeadLeft">
            <span class="pill">Note ID: ${esc(noteId)}</span>
            <span class="pill">Appended by: ${esc(appendedBy || "(unknown)")}</span>
          </div>
          <div class="dateRight">${esc(dateStr)}</div>
        </div>

        <pre>${esc(bodyText)}</pre>

        <div class="row">
          <button type="button" onclick="openEdit('${esc(noteId)}')">Edit / 編集</button>
          <button type="button" class="danger" onclick="deleteNote('${esc(noteId)}')">Delete / 削除</button>
        </div>

        <div class="appendBox" id="appendBox_${esc(noteId)}">
          <textarea id="appendText_${esc(noteId)}"></textarea>
          <div class="row">
            <button type="button" onclick="saveEdit('${esc(noteId)}')">Save / 保存</button>
            <button type="button" onclick="closeEdit('${esc(noteId)}')">Cancel / キャンセル</button>
          </div>
        </div>
      `;
      box.appendChild(div);
    }
  }

  async function loadAll(){
    const id = getId();
    if (!id){ qs("meta").textContent = "Missing ?id="; return; }
    CONTACT_ID = id;
    setStatus("Loading... / 読み込み中...");

    try { await loadMe(); } catch {}

    // get contact (new first, compat fallback)
    let c = await api(`/api/contacts/get?id=${encodeURIComponent(id)}`);
    if (!c.ok) c = await api(`/api/contacts/${encodeURIComponent(id)}`);
    if (!c.ok){ setStatus(""); alert(`Failed: ${c.status}\n` + c.raw); return; }

    const props = c.data?.properties || {};
    renderProfile(props, id);

    // notes (new first, compat fallback)
    let n = await api(`/api/notes/list?contactId=${encodeURIComponent(id)}`);
    if (!n.ok) n = await api(`/api/contacts/${encodeURIComponent(id)}/notes`);
    if (!n.ok){ setStatus(""); alert(`Failed notes: ${n.status}\n` + n.raw); return; }

    NOTES_CACHE = (n.data?.notes || []).slice();
    renderNotes();
    setStatus("");
  }

  async function addNote(){
    const body = (qs("newNote").value||"").trim();
    if (!body){ alert("Please enter a note. / メモを入力してください"); return; }
    setStatus("Saving... / 保存中...");

    let r = await api(`/api/notes/create`, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify({ contactId: CONTACT_ID, body })
    });

    if (!r.ok){
      // compat fallback
      r = await api(`/api/contacts/${encodeURIComponent(CONTACT_ID)}/notes`, {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify({ body })
      });
    }

    if (!r.ok){
      setStatus("");
      alert(`Add note failed: ${r.status}\n` + r.raw);
      return;
    }

    qs("newNote").value = "";
    await loadAll();
    setStatus("Saved / 保存しました");
  }

  function openEdit(noteId){
    for (const n of NOTES_CACHE){
      const b = document.getElementById("appendBox_" + n.id);
      if (b) b.style.display = "none";
    }
    const box = document.getElementById("appendBox_" + noteId);
    const ta = document.getElementById("appendText_" + noteId);
    if (!box || !ta) return;

    const note = NOTES_CACHE.find(x => String(x.id) === String(noteId));
    if (note?.body != null) ta.value = normalizeNoteBodyToPlain(note.body || "");
    else {
      const plainAll = normalizeNoteBodyToPlain(note?.hs_note_body || "");
      const meta = extractMetaAndStrip(plainAll);
      ta.value = normalizeNoteBodyToPlain(stripAuditLines(meta.textWithoutMeta));
    }

    box.style.display = "block";
    ta.focus();
  }

  function closeEdit(noteId){
    const box = document.getElementById("appendBox_" + noteId);
    if (box) box.style.display = "none";
  }

  async function saveEdit(noteId){
    const ta = document.getElementById("appendText_" + noteId);
    const text = (ta?.value||"").trim();
    if (!text){ alert("Please enter content. / 内容を入力してください"); return; }
    setStatus("Updating... / 更新中...");

    let r = await api(`/api/notes/update`, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify({ noteId, body: text })
    });

    if (!r.ok){
      r = await api(`/api/notes/${encodeURIComponent(noteId)}/append`, {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify({ text })
      });
    }

    if (!r.ok){ setStatus(""); alert(`Update failed: ${r.status}\n` + r.raw); return; }

    await loadAll();
    setStatus("Saved / 保存しました");
  }

  async function deleteNote(noteId){
    if (!confirm("Delete this note? / このメモを削除しますか？")) return;
    if (!confirm("This cannot be undone. Continue? / 元に戻せません。続行しますか？")) return;

    setStatus("Deleting... / 削除中...");

    let r = await api(`/api/notes/delete`, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify({ noteId })
    });

    if (!r.ok){
      r = await api(`/api/notes/${encodeURIComponent(noteId)}`, { method:"DELETE" });
    }

    if (!r.ok){ setStatus(""); alert(`Delete failed: ${r.status}\n` + r.raw); return; }

    await loadAll();
    setStatus("Deleted / 削除しました");
  }

  qs("addBtn").onclick = () => addNote();
  qs("reloadBtn").onclick = () => loadAll();
  loadAll();
</script>

</body>
</html>
